{
    "contents" : "#' Builds a food web according to the cascade model\n#'\n#' The cascade model is described in Cohen et al. \"Community food webs: Data and theory\", 1990.\n#' The species are sorted in order from 1...S and each species has probability C of consuming any of the\n#' preceding species.\n#' @param S The number of species (integer)\n#' @param C The desired connectance (between 0 and 1)\n#' @return A connected (one piece) food web of connectance close to the desired value.\n#' The food web is a list containing:\n#' \\describe{\n#' \\item{$links}{The trophic links from resource to consumer (L x 2 matrix)}\n#' \\item{$S}{The number of species}\n#' \\item{$L}{The number of links}\n#' \\item{$C}{The connectance L / (S choose 2)}\n#' \\item{$Model}{A code for the model used to generate the food web}\n#' \\item{$Cycles}{Boolean, whether cycles are present}\n#' }\n#' All the self-loops and double arrows (a eats b, b eats a) are removed. If the food web contains\n#' no cycles, then it is sorted that all the coefficients would be in the upper-triangular part\n#' of the corresponding adjacency matrix.\n#'\n#' If the resulting network has connectance too different from the desired one, or it is not connected,\n#' the function will call itself recursively. If too many recursions are performed, it will fail.\n#' @examples\n#' FW <- eye.foodweb.cascade() # S = 100, C = 0.25\n#' FW <- eye.foodweb.cascade(30, 0.2)\n#' FW <- eye.foodweb.cascade(S = 250, C = 0.314)\neye.foodweb.cascade <- function(S = 100, C = 0.25){\n  ## Build the adjacency matrix\n  K <- (matrix(runif(S * S), S, S) < C) * 1\n  K[lower.tri(K)] <- 0\n  diag(K) <- 0\n  ## Now check that it passes all the following criteria\n  ## a) the number of connections is about right\n  L <- sum(K)\n  expected.L <- choose(S, 2) * C\n  variance.L <- choose(S, 2) * C * (1. - C)\n  if (L < (expected.L - 2 * sqrt(variance.L)) |\n      L > (expected.L + 2 * sqrt(variance.L))){\n        warning(\"Failed to build foodweb, wrong number of links. Trying again...\")\n        return(eye.foodweb.cascade(S, C))\n      }\n  ## b) The network is connected\n  g <- graph.adjacency(K, mode = \"directed\")\n  if (is.connected(g, mode = \"weak\") == FALSE){\n    warning(\"Failed to build foodweb, not connected. Trying again...\")\n    return(eye.foodweb.cascade(S, C))\n  }\n  ## If it passes the tests, then build the foodweb\n  fw <- list()\n  fw$links <- get.edgelist(g)\n  fw$S <- S\n  fw$L <- dim(fw$links)[1]\n  fw$C <- fw$L / (S * (S - 1) * 0.5)\n  fw$Model <- \"Cascade\"\n  fw$Cycles <- FALSE\n  return(fw)\n}\n\n#' Builds a food web according to the niche model\n#'\n#' The niche model is described in Williams and Martinez, Nature 2000.\n#' The species are sorted in order from 1...S and each species consumes a set of\n#' adjacent species.\n#' @param S The number of species (integer)\n#' @param C The desired connectance (between 0 and 1)\n#' @return A connected (one piece) food web of connectance close to the desired value.\n#' The food web is a list containing:\n#' \\describe{\n#' \\item{$links}{The trophic links from resource to consumer (L x 2 matrix)}\n#' \\item{$S}{The number of species}\n#' \\item{$L}{The number of links}\n#' \\item{$C}{The connectance L / (S choose 2)}\n#' \\item{$Model}{A code for the model used to generate the food web}\n#' \\item{$Cycles}{Boolean, whether cycles are present}\n#' }\n#' All the self-loops and double arrows (a eats b, b eats a) are removed. If the food web contains\n#' no cycles, then it is sorted that all the coefficients would be in the upper-triangular part\n#' of the corresponding adjacency matrix.\n#'\n#' If the resulting network has connectance too different from the desired one, or it is not connected,\n#' the function will call itself recursively. If too many recursions are performed, it will fail.\n#' @examples\n#' FW <- eye.foodweb.niche() # S = 100, C = 0.25\n#' FW <- eye.foodweb.niche(30, 0.2)\n#' FW <- eye.foodweb.niche(S = 250, C = 0.314)\neye.foodweb.niche <- function(S = 100, C = 0.25){\n  ## Build the adjacency matrix\n  K <- matrix(0, S, S)\n  ## assign the niche value for all species\n  ## Note: the niche values of the species are ordered\n  ni <- sort(runif(S, 0, 1))\n  ## determine the radius of the food spectrum for each species\n  ## the radius is drawn randomly from a ni * Beta(1, beta) distribution\n  beta <- 1.0 / C - 1\n  ri <- rbeta(S, 1, beta) * ni\n  ## Set species with the lowest niche value to be the basal species\n  ri[1] <- 0\n  ## The center of the food spectrum for each species are\n  ## drawn uniformly from an uniform distribution on [ri/2, ni]\n  ci <- numeric(S)\n  for(i in 1:S){\n    ci[i] <- runif(1, ri[i] / 2, min(ni[i], 1 - ri[i] / 2))\n    ## Correction as in Allesina et al Science 2008\n    ## Determine the boundary for the food spectrum for each species:\n    upper <- ci[i] + ri[i] / 2\n    lower <- ci[i] - ri[i] / 2\n    ## check which species are falling into that interval: [lower, upper]\n    ## and set the corresponding value in the ajacency matrix M to be 1,\n    ## indicating a link is established between the two species.\n    for(j in 1:S){\n      if(ni[j] > lower & ni[j] < upper)\n        K[j, i] <- 1\n        ## remove double edges\n        if (K[i, j] == 1) {\n          ## remove one at random\n          if (runif(1) < 0.5){\n            K[i, j] <- 0\n          } else {\n            K[j, i] <- 0\n          }\n        }\n    }\n  }\n  diag(K) <- 0\n  ## Now check that it passes all the following criteria\n  ## a) the number of connections is about right\n  L <- sum(K)\n  expected.L <- choose(S, 2) * C\n  variance.L <- choose(S, 2) * C * (1. - C)\n  if (L < (expected.L - 2 * sqrt(variance.L)) |\n        L > (expected.L + 2 * sqrt(variance.L))){\n    warning(\"Failed to build foodweb, wrong number of links. Trying again...\")\n    return(eye.foodweb.niche(S, C))\n  }\n  ## b) The network is connected\n  g <- graph.adjacency(K, mode = \"directed\")\n  if (is.connected(g, mode = \"weak\") == FALSE){\n    warning(\"Failed to build foodweb, not connected. Trying again...\")\n    return(eye.foodweb.niche(S, C))\n  }\n  ## c) Check if it has no cycles. If so, perform a topological sort\n  ts <- topological.sort(g)\n  if (length(ts) == S){\n    K <- K[ts, ts]\n    g <- graph.adjacency(K, mode = \"directed\")\n    Cycles <- FALSE\n  } else {\n    Cycles <- TRUE\n  }\n  ## If it passes the tests, then build the foodweb\n  fw <- list()\n  fw$links <- get.edgelist(g)\n  fw$S <- S\n  fw$L <- dim(fw$links)[1]\n  fw$C <- fw$L / (S * (S - 1) * 0.5)\n  fw$Model <- \"Niche\"\n  fw$Cycles <- Cycles\n  return(fw)\n}\n\n#' Build a food web reading a file\n#'\n#' Read the binary adjacency matrix contained in the file.\n#' Remove self-loops and double edges\n#' @param filename A text file containing the adjacency matrix (binary, rows = resources, cols = consumers) of a food web\n#' The food web is a list containing:\n#' \\describe{\n#' \\item{$links}{The trophic links from resource to consumer (L x 2 matrix)}\n#' \\item{$S}{The number of species}\n#' \\item{$L}{The number of links}\n#' \\item{$C}{The connectance L / (S choose 2)}\n#' \\item{$Model}{A code for the model used to generate the food web}\n#' \\item{$Cycles}{Boolean, whether cycles are present}\n#' }\n#' All the self-loops and double arrows (a eats b, b eats a) are removed. If the food web contains\n#' no cycles, then it is sorted that all the coefficients would be in the upper-triangular part\n#' of the corresponding adjacency matrix.\n#' @examples\n#' FW <- eye.foodweb.file(\"myadjacencymat.txt\")\neye.foodweb.file <- function(filename){\n  ## Build the adjacency matrix\n  K <- (as.matrix(read.table(filename, header = FALSE)) > 0) * 1\n  colnames(K) <- NULL\n  rownames(K) <- NULL\n  S <- dim(K)[1]\n  diag(K) <- 0\n  ## Check double arrows\n  KK <- K + t(K)\n  KK[upper.tri(KK)] <- 0\n  KK <- (KK == 2) * 1\n  K <- K - KK\n  g <- graph.adjacency(K, mode = \"directed\")\n  ## Check if it has no cycles. If so, perform a topological sort\n  ts <- topological.sort(g)\n  if (length(ts) == S){\n    K <- K[ts, ts]\n    g <- graph.adjacency(K, mode = \"directed\")\n    Cycles <- FALSE\n  } else {\n    Cycles <- TRUE\n  }\n  ## Build the foodweb\n  fw <- list()\n  fw$links <- get.edgelist(g)\n  fw$S <- S\n  fw$L <- dim(fw$links)[1]\n  fw$C <- fw$L / (S * (S - 1) * 0.5)\n  fw$Model <- \"From File\"\n  fw$Cycles <- Cycles\n  return(fw)\n}\n",
    "created" : 1412464561301.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3268309002",
    "id" : "7CFAAAFC",
    "lastKnownWriteTime" : 1412465511,
    "path" : "~/RPackages/eyeball/R/buildfoodwebs.R",
    "project_path" : "R/buildfoodwebs.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}